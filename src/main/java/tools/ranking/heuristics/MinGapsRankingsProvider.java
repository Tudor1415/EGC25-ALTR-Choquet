package tools.ranking.heuristics;

import static java.lang.Math.abs;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import lombok.Getter;
import lombok.Setter;
import tools.alternatives.Alternative;
import tools.alternatives.IAlternative;
import tools.functions.singlevariate.ISinglevariateFunction;
import tools.normalization.Normalizer;
import tools.normalization.Normalizer.NormalizationMethod;
import tools.oracles.ArtificialOracle;
import tools.oracles.Oracle;
import tools.ranking.Ranking;
import tools.ranking.RankingsProvider;
import tools.rules.DecisionRule;
import tools.train.LearnStep;
import tools.utils.RandomUtil;
import tools.utils.RankingUtil;

/**
 * A ranking provider based on an alternative selection heuristic (section
 * 4.3.1, page 6) as proposed by Belmecheri et al. in "Boosting the learning for
 * ranking patterns."
 * This provider generates rankings by selecting alternatives with minimal gaps
 * in their score function values. It first samples the rules using the current
 * state of the function. Then it selects the desired alternatives and
 * only then, ranks them using the oracle. Only a pair of alternatives are given
 * to the oracle.
 * 
 * @param oracle     The comparator used as an oracle for ranking comparisons.
 * @param sampler    The sampling instance used to sample the rules.
 * @param sampleSize The size of the random sample used for ranking
 *                   generation.
 */
public class MinGapsRankingsProvider implements RankingsProvider {

    // The oracle used to rank the selected pair of rules
    private ArtificialOracle oracle;
    private @Getter @Setter double noise = 0.0d;

    // The state of the approximation function at the current iteration
    private @Getter ISinglevariateFunction scoreFunction;

    // The sampling instance used to sample the rules
    private DecisionRule[] sample;
    private Normalizer normalizer = new Normalizer();

    // The list of all selected pairs of alternatives from all the iterations
    // and their respective ranking given by the oracle.
    private Set<IAlternative[]> selectedPairs = new HashSet<>();
    private List<Ranking<IAlternative>> rankings = new ArrayList<>();

    // The random instance used for random sampling
    private RandomUtil random = RandomUtil.getInstance();

    public MinGapsRankingsProvider(ArtificialOracle oracle,
            DecisionRule[] sample) {
        this.oracle = oracle;
        this.sample = sample;

        for (DecisionRule rule : sample)
            normalizer.normalize(rule.getAlternative().getVector(), NormalizationMethod.NO_NORMALIZATION, true);
    }

    /**
     * Measures the gap between two alternatives based on their score function
     * values and vector differences.
     *
     * @param a The first alternative.
     * @param b The second alternative.
     * @return The computed gap between the two alternatives.
     */
    private double measureGap(IAlternative a, IAlternative b) {
        IAlternative norm_a = new Alternative(
                normalizer.normalize(a.getVector(), NormalizationMethod.MIN_MAX_SCALING, false));
        IAlternative norm_b = new Alternative(
                normalizer.normalize(b.getVector(), NormalizationMethod.MIN_MAX_SCALING, false));

        double num = abs(scoreFunction.computeScore(norm_a) - scoreFunction.computeScore(norm_b));
        double denom = 0d;
        for (int i = 0; i < a.getVector().length; i++) {
            denom += abs(a.getVector()[i] - b.getVector()[i]);
        }
        return num / denom;
    }

    private int[] randomSample(int size, int sampleSize) {
        return random.kFolds(1, size, sampleSize)[0];
    }

    /**
     * The algorithm selects pairs of alternatives with minimal gaps in their score
     * and generates rankings for each pair.
     * The process is repeated until the desired number of rankings is obtained.
     *
     * @param step The current iteration step containing the score function and
     *             other information.
     * @return A list of rankings generated by the MinGapsRankingsProvider
     *         algorithm.
     */
    @Override
    public List<Ranking<IAlternative>> provideRankings(LearnStep step) {
        // Retrieving the state of the approximation function at the current iteration
        scoreFunction = step.getCurrentScoreFunction();

        // int randomSampleSize = Math.min(sample.length - 1, 10);
        int randomSampleSize = 50;
        int[] randomSample = randomSample(sample.length, randomSampleSize);

        // Searching for the pair of alternatives with the minimum gap using a heuristic
        double minGap = Double.MAX_VALUE;

        int a1Index = -1;
        int a2Index = -1;
        for (int i = 0; i < randomSampleSize; i++) {
            for (int j = i + 1; j < randomSampleSize; j++) {
                int iIndex = randomSample[i];
                int jIndex = randomSample[j];
                if (selectedPairs.contains(
                        new IAlternative[] { sample[iIndex].getAlternative(), sample[jIndex].getAlternative() })) {
                    continue;
                }
                double measureGap = measureGap(sample[iIndex].getAlternative(), sample[jIndex].getAlternative());
                if (measureGap < minGap) {
                    minGap = measureGap;
                    a1Index = iIndex;
                    a2Index = jIndex;
                }
            }
        }

        // Add the selected pair to the set of selected pairs
        IAlternative norm_a = new Alternative(normalizer.normalize(sample[a1Index].getAlternative().getVector(),
                NormalizationMethod.MIN_MAX_SCALING, false));
        IAlternative norm_b = new Alternative(normalizer.normalize(sample[a2Index].getAlternative().getVector(),
                NormalizationMethod.MIN_MAX_SCALING, false));

        IAlternative[] alternativePair = new IAlternative[] { norm_a, norm_b };
        List<DecisionRule> rulePair = new ArrayList<>();
        rulePair.add(sample[a1Index]);
        rulePair.add(sample[a2Index]);

        selectedPairs.add(alternativePair);

        // Compute the ranking for the selected pair using the oracle
        if (oracle instanceof ArtificialOracle) {
            if (getNoise() == 0) {
                rankings.add(RankingUtil.computeRankingWithOracle(oracle, rulePair, alternativePair));
            } else {
                rankings.add(RankingUtil.computeNoisyRankingWithOracle(oracle, rulePair, getNoise()));
            }
        } else if (oracle instanceof Oracle) {
            rankings.add(RankingUtil.computeRankingWithOracle(oracle, rulePair, alternativePair));
        } else {
            throw new IllegalArgumentException("Unsupported Oracle type: " + oracle.getClass().getName());
        }

        // Return all the computed rankings (from all the prior iterations including
        // this one)
        return rankings;
    }
}