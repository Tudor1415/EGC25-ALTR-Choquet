package tools.ranking.heuristics;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import lombok.Getter;
import lombok.Setter;
import sampling.SMAS;
import tools.alternatives.Alternative;
import tools.alternatives.IAlternative;
import tools.data.Dataset;
import tools.functions.multivariate.CertaintyFunction;
import tools.functions.multivariate.outRankingCertainties.BradleyTerry;
import tools.functions.singlevariate.ISinglevariateFunction;
import tools.functions.singlevariate.LinearScoreFunction;
import tools.normalization.Normalizer;
import tools.normalization.Normalizer.NormalizationMethod;
import tools.oracles.ArtificialOracle;
import tools.oracles.Oracle;
import tools.ranking.Ranking;
import tools.ranking.RankingsProvider;
import tools.rules.DecisionRule;
import tools.train.LearnStep;
import tools.utils.RankingUtil;

public class TopTwoRules implements RankingsProvider {

    private @Getter @Setter double noise;

    // The oracle used to rank the selected pair of rules
    private ArtificialOracle oracle;

    // The state of the approximation function at the current iteration
    private @Getter ISinglevariateFunction scoreFunction;

    // The sampling instance used to sample the rules
    private @Getter SMAS sampler;

    // The maximum iterations used for sampling
    private @Setter @Getter int maximum_iterations = 10_000;

    // The list of all selected pairs of alternatives from all the iterations
    // and their respective ranking given by the oracle.
    private Set<IAlternative[]> selectedPairs = new HashSet<>();
    private List<Ranking<IAlternative>> rankings = new ArrayList<>();

    private static final double DEFAULT_NOISE = 0d;
    private static final double SMOOTH_COUNTS = 0.01d;
    private static final int TOP_K = 2;
    private static final int MAXIMUM_ITERATIONS = 10_000;

    public TopTwoRules(ArtificialOracle oracle, Dataset dataset, String[] measureNames, double noise) {
        this(oracle, dataset, measureNames, noise, MAXIMUM_ITERATIONS, NormalizationMethod.MIN_MAX_SCALING);
    }

    public TopTwoRules(ArtificialOracle oracle, Dataset dataset, String[] measureNames) {
        this(oracle, dataset, measureNames, DEFAULT_NOISE, MAXIMUM_ITERATIONS, NormalizationMethod.MIN_MAX_SCALING);
    }

    public TopTwoRules(ArtificialOracle oracle, Dataset dataset, String[] measureNames, double noise,
            int maximumIterations, NormalizationMethod normalizationMethod) {
        this.oracle = oracle;
        this.noise = noise;
        initializeSampler(dataset, measureNames, maximumIterations);
        setSamplerNormalizationMethod(normalizationMethod);
        
    }

    private void initializeSampler(Dataset dataset, String[] measureNames, int maximumIterations) {
        ISinglevariateFunction initialFunction = new LinearScoreFunction();
        CertaintyFunction outRankingCertainty = new BradleyTerry(initialFunction);
        this.sampler = new SMAS(maximumIterations, dataset, outRankingCertainty, initialFunction, measureNames,
                SMOOTH_COUNTS, TOP_K);
    }

    /**
     * The algorithm selects pairs of alternatives with minimal gaps in their score
     * and generates rankings for each pair.
     * The process is repeated until the desired number of rankings is obtained.
     *
     * @param step The current iteration step containing the score function and
     *             other information.
     * @return A list of rankings generated by the MinGapsRankingsProvider
     *         algorithm.
     */
    @Override
    public List<Ranking<IAlternative>> provideRankings(LearnStep step) {
        // Retrieving the state of the approximation function at the current iteration
        scoreFunction = step.getCurrentScoreFunction();

        // Sampling new rules using the sampler with the updated approximation function
        sampler.setScoringFunction(scoreFunction);

        // Sample new alternatives from the test dataset
        List<DecisionRule> sample = sampler.sample();

        Normalizer normalizer = sampler.getNormalizer();

        Alternative normalized0 = new Alternative(normalizer.normalize(sample.get(0).getAlternative().getVector(), NormalizationMethod.MIN_MAX_SCALING, false));
        Alternative normalized1 = new Alternative(normalizer.normalize(sample.get(1).getAlternative().getVector(), NormalizationMethod.MIN_MAX_SCALING, false));

        // Add the selected pair to the set of selected pairs
        IAlternative[] alternativePair = new IAlternative[] { normalized0, normalized1 };
        selectedPairs.add(alternativePair);

        // Compute the ranking for the selected pair using the oracle
        if (oracle instanceof ArtificialOracle) {
            if (getNoise() == 0) {
                rankings.add(RankingUtil.computeRankingWithOracle(oracle, sample, alternativePair));
            } else {
                rankings.add(RankingUtil.computeNoisyRankingWithOracle((ArtificialOracle) oracle, sample, getNoise()));
            }
        } else if (oracle instanceof Oracle) {
            rankings.add(RankingUtil.computeRankingWithOracle(oracle, sample, alternativePair));
        } else {
            throw new IllegalArgumentException("Unsupported Oracle type: " + oracle.getClass().getName());
        }        

        // Return all the computed rankings (from all the prior iterations including
        // this one)
        return rankings;
    }

    public void setSamplerNormalizationMethod(NormalizationMethod normalizationMethod) {
        sampler.setNormalizationTechnique(normalizationMethod);
    }
}